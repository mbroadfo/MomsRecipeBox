// File: app/local_server.js
import { handler } from './lambda.js';
import http from 'http';
import fs from 'fs';
import path from 'path';
import url from 'url';

const PORT = process.env.PORT || 3000;

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
function handleResponse(res, result, event = {}) {
  // Extract user ID if present in query params
  const userId = event.queryStringParameters?.user_id || 'anonymous';
  const method = event.httpMethod || 'UNKNOWN';
  const path = event.path || 'unknown path';
  
  // Log request completion with user ID and response status (green for successful responses)
  const colorCode = result.statusCode < 400 ? '\x1b[32m' : '\x1b[31m';
  console.log(`${colorCode}<-- [${userId}] ${method} ${path} â†’ ${result.statusCode}\x1b[0m`);
  
  // For debugging binary responses onlyonse(res, result, event = {}) {
  // Extract user ID if present in query params
  const userId = event.queryStringParameters?.user_id || 'anonymous';
        // Log the incoming request
      const userId = queryStringParameters.user_id || 'anonymous';
      console.log(`IN  [${userId}] ${req.method} ${req.url}`);st method = event.httpMethod || 'UNKNOWN';
  const path = event.path || 'unknown path';
  
  // Log request completion with user ID and response status
  console.log(`OUT [${userId}] ${method} ${path} â†’ ${result.statusCode}`);erver.js
import { handler } from './lambda.js';
import http from 'http';
import fs from 'fs';
import path from 'path';
import url from 'url';

const PORT = process.env.PORT || 3000;

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));

// Centralized response handler function
function handleResponse(res, result, event = {}) {
  // Extract user ID if present in query params
  const userId = event.queryStringParameters?.user_id || 'anonymous';
  const method = event.httpMethod || 'UNKNOWN';
  const path = event.path || 'unknown path';
  
  // Log request completion with user ID and response status
  console.log(`ï¿½ [${userId}] ${method} ${path} â†’ ${result.statusCode}`);
  
  // For debugging binary responses only
  if (result.isBase64Encoded || Buffer.isBuffer(result.body)) {
    const bodyLength = result.body ? (Buffer.isBuffer(result.body) ? result.body.length : (typeof result.body === 'string' ? result.body.length : 'unknown')) : 0;
    console.debug(`ðŸ“· Binary response, length: ${bodyLength} bytes`);
  }
  
  // Handle base64 encoded responses (for binary data like images)
  if (result.isBase64Encoded && typeof result.body === 'string') {
    console.debug('Handling base64 encoded response');
    const buffer = Buffer.from(result.body, 'base64');
    console.debug(`Decoded base64 buffer, length: ${buffer.length} bytes`);
    console.debug('Buffer first 16 bytes:', buffer.slice(0, 16).toString('hex'));
    
    // Ensure Content-Disposition is set for inline viewing
    const headers = { ...result.headers };
    if (!headers['Content-Disposition']) {
      headers['Content-Disposition'] = 'inline';
    }
    
    // Set proper headers for binary data
    res.writeHead(result.statusCode, {
      ...headers,
      'Content-Type': headers['Content-Type'] || 'application/octet-stream',
      'Content-Length': buffer.length
    });
    
    // Write the binary buffer directly to the response
    res.end(buffer);
  } 
  // Handle raw binary responses (non-base64)
  else if (!result.isBase64Encoded && Buffer.isBuffer(result.body)) {
    console.debug(`Handling raw binary response, length: ${result.body.length} bytes`);
    console.debug('Buffer first 16 bytes:', result.body.slice(0, 16).toString('hex'));
    
    // Ensure Content-Disposition is set for inline viewing
    const headers = { ...result.headers };
    if (!headers['Content-Disposition']) {
      headers['Content-Disposition'] = 'inline';
    }
    
    res.writeHead(result.statusCode, {
      ...headers,
      'Content-Type': headers['Content-Type'] || 'application/octet-stream',
      'Content-Length': result.body.length
    });
    
    res.end(result.body);
  } 
  // Handle regular string/JSON responses
  else {
    res.writeHead(result.statusCode || 200, result.headers || { 'Content-Type': 'application/json' });
    res.end(typeof result.body === 'string' ? result.body : JSON.stringify(result.body));
  }
}


const server = http.createServer(async (req, res) => {
  // Serve Swagger YAML
  if (req.url === '/api-docs/swagger.yaml') {
    const filePath = path.join(__dirname, 'docs', 'swagger.yaml');
    fs.readFile(filePath, (err, data) => {
      if (err) {
        res.writeHead(404, { 'Content-Type': 'text/plain' });
        res.end('Not found');
      } else {
        res.writeHead(200, { 'Content-Type': 'application/x-yaml' });
        res.end(data);
      }
    });
    return;
  }

  // Serve Swagger UI at /api-docs
  if (req.url === '/api-docs') {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Swagger UI</title>
        <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist/swagger-ui.css" />
      </head>
      <body>
        <div id="swagger-ui"></div>
        <script src="https://unpkg.com/swagger-ui-dist/swagger-ui-bundle.js"></script>
        <script>
          window.onload = () => {
            window.ui = SwaggerUIBundle({
              url: '/api-docs/swagger.yaml',
              dom_id: '#swagger-ui',
            });
          };
        </script>
      </body>
      </html>
    `);
    return;
  }

  // Remove query string for path matching
  const cleanPath = req.url.split('?')[0];
  let pathParameters = {};
  // /comments/{id}
  const commentMatch = cleanPath.match(/^\/comments\/([\w-]+)$/);
  if (commentMatch) {
    pathParameters.comment_id = commentMatch[1];
  }
  // /recipes/{id}/comments
  const recipeCommentMatch = cleanPath.match(/^\/recipes\/([\w-]+)\/comments$/);
  if (recipeCommentMatch) {
    pathParameters.id = recipeCommentMatch[1];
  }
  // /recipes/{id}/like
  const recipeLikeMatch = cleanPath.match(/^\/recipes\/([\w-]+)\/like$/);
  if (recipeLikeMatch) {
    pathParameters.id = recipeLikeMatch[1];
  }
  // /recipes/{id}
  const recipeIdMatch = cleanPath.match(/^\/recipes\/([\w-]+)$/);
  if (recipeIdMatch) {
    pathParameters.id = recipeIdMatch[1];
  }
  // /recipes/{id}/image - fix capture group
  const recipeImageMatch = cleanPath.match(/^\/recipes\/([\w-]+)\/image$/);
  if (recipeImageMatch) {
    pathParameters.id = recipeImageMatch[1];
  }

  // Handle the request differently based on content type
  if (
    req.headers['content-type'] &&
    req.headers['content-type'].startsWith('multipart/form-data')
  ) {
    // For multipart, pass the raw req object to the handler
    const event = {
      httpMethod: req.method,
      path: req.url,
      headers: req.headers,
      body: req, // Pass the raw request object
      pathParameters,
    };
    const context = {};
    
    try {
      // Extract user ID if present in query params
      const urlParts = req.url.split('?');
      let queryStringParameters = {};
      if (urlParts.length > 1) {
        const queryString = urlParts[1];
        queryString.split('&').forEach(param => {
          const [key, value] = param.split('=');
          if (key && value) {
            queryStringParameters[key] = decodeURIComponent(value);
          }
        });
      }
      event.queryStringParameters = queryStringParameters;
      
      // Log the incoming request
      const userId = queryStringParameters.user_id || 'anonymous';
      console.log(`ï¿½ [${userId}] ${req.method} ${req.url}`);
      
      const result = await handler(event, context);
      handleResponse(res, result, event);
    } catch (err) {
      console.error(err);
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Internal Server Error' }));
    }
  } else {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });

    req.on('end', async () => {
      try {
        // Remove query string for path matching
        const urlParts = req.url.split('?');
        const cleanPath = urlParts[0];
        
        // Parse query parameters
        let queryStringParameters = {};
        if (urlParts.length > 1) {
          const queryString = urlParts[1];
          queryString.split('&').forEach(param => {
            const [key, value] = param.split('=');
            if (key && value) {
              queryStringParameters[key] = decodeURIComponent(value);
            }
          });
        }
        
        // Log the incoming request with user ID if available
        const userId = queryStringParameters.user_id || 'anonymous';
        console.log(`ï¿½ [${userId}] ${req.method} ${req.url}`);
        
        let pathParameters = {};
        // /comments/{id}
        const commentMatch = cleanPath.match(/^\/comments\/([\w-]+)$/);
        if (commentMatch) {
          pathParameters.comment_id = commentMatch[1];
        }
        // /recipes/{id}/comments
        const recipeCommentMatch = cleanPath.match(/^\/recipes\/([\w-]+)\/comments$/);
        if (recipeCommentMatch) {
          pathParameters.id = recipeCommentMatch[1];
        }
        // /recipes/{id}/like
        const recipeLikeMatch = cleanPath.match(/^\/recipes\/([\w-]+)\/like$/);
        if (recipeLikeMatch) {
          pathParameters.id = recipeLikeMatch[1];
        }
        // /recipes/{id}
        const recipeIdMatch = cleanPath.match(/^\/recipes\/([\w-]+)$/);
        if (recipeIdMatch) {
          pathParameters.id = recipeIdMatch[1];
        }
        // /recipes/{id}/image - fix capture group
        const recipeImageMatch = cleanPath.match(/^\/recipes\/([\w-]+)\/image$/);
        if (recipeImageMatch) {
          pathParameters.id = recipeImageMatch[1];
        }

        // Patch: Set content-length header for multipart/form-data if missing
        if (
          req.headers['content-type'] &&
          req.headers['content-type'].startsWith('multipart/form-data') &&
          !req.headers['content-length']
        ) {
          req.headers['content-length'] = Buffer.byteLength(body);
        }
        const event = {
          httpMethod: req.method,
          path: req.url,
          headers: req.headers,
          body: body || null,
          pathParameters,
          queryStringParameters,
        };

        const context = {};

        const result = await handler(event, context);
        handleResponse(res, result, event);
      } catch (err) {
        console.error('Error processing request:', err);
        const errorResult = {
          statusCode: 500,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ error: 'Internal Server Error', message: err.message })
        };
        handleResponse(res, errorResult);
      }
    });
  }
});

server.listen(PORT, () => {
  console.log(`ðŸš€ Local server running at http://localhost:${PORT}`);
});
