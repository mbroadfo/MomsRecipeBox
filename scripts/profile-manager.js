#!/usr/bin/env node

/**
 * Profile Manager for Mom's Recipe Box
 * Manages deployment profiles and environment configuration
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.resolve(__dirname, '..');
const CONFIG_DIR = path.join(ROOT_DIR, 'config');
const PROFILES_FILE = path.join(CONFIG_DIR, 'deployment-profiles.json');
const CURRENT_PROFILE_FILE = path.join(CONFIG_DIR, 'current-profile.env');
const ROOT_ENV_FILE = path.join(ROOT_DIR, '.env');

/**
 * Fetch MongoDB Atlas URI from AWS Secrets Manager
 */
// Fetch secrets from AWS Secrets Manager
async function fetchSecretsFromAWS(secretName = 'moms-recipe-secrets-dev', region = 'us-west-2') {
  try {
    // Build AWS CLI command with profile if set
    let awsCommand = `aws secretsmanager get-secret-value --secret-id ${secretName} --region ${region} --output json`;
    if (process.env.AWS_PROFILE) {
      awsCommand += ` --profile ${process.env.AWS_PROFILE}`;
    }
    
    // Execute AWS CLI command
    const result = execSync(awsCommand, { encoding: 'utf8', stdio: 'pipe' });
    const secretData = JSON.parse(result);
    
    if (secretData && secretData.SecretString) {
      return JSON.parse(secretData.SecretString);
    }
    
    return {};
  } catch (error) {
    // Silently fail and return empty object - caller will handle the missing values
    return {};
  }
}

// Legacy function for backward compatibility
async function fetchMongoAtlasUri(secretName = 'moms-recipe-secrets-dev', region = 'us-west-2') {
  try {
    const secrets = await fetchSecretsFromAWS(secretName, region);
    return secrets.MONGODB_URI || secrets.MONGODB_ATLAS_URI || null;
  } catch (error) {
    return null;
  }
}

// ANSI color codes
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function showBanner() {
  const banner = `
 ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
 ‚ïë  Profile Manager for Mom's Recipe Box         ‚ïë
 ‚ïë  Four-Profile Deployment Architecture         ‚ïë
 ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;
  log(banner, 'cyan');
}

// Load deployment profiles
function loadProfiles() {
  if (!fs.existsSync(PROFILES_FILE)) {
    log(`‚ùå Profiles file not found: ${PROFILES_FILE}`, 'red');
    process.exit(1);
  }
  
  try {
    const content = fs.readFileSync(PROFILES_FILE, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    log(`‚ùå Error loading profiles: ${error.message}`, 'red');
    process.exit(1);
  }
}

// Save deployment profiles
function saveProfiles(profiles) {
  try {
    const content = JSON.stringify(profiles, null, 2);
    fs.writeFileSync(PROFILES_FILE, content);
    log(`‚úÖ Profiles saved to ${PROFILES_FILE}`, 'green');
  } catch (error) {
    log(`‚ùå Error saving profiles: ${error.message}`, 'red');
    process.exit(1);
  }
}

// Load environment variables from root .env
function loadStaticEnv() {
  const env = {};
  
  if (fs.existsSync(ROOT_ENV_FILE)) {
    const content = fs.readFileSync(ROOT_ENV_FILE, 'utf8');
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key && valueParts.length > 0) {
          env[key.trim()] = valueParts.join('=').trim();
        }
      }
    }
  }
  
  return env;
}

// Replace environment variable placeholders
function replaceEnvVars(value, env) {
  if (typeof value !== 'string') return value;
  
  return value.replace(/\$\{([^}]+)\}/g, (match, varName) => {
    return env[varName] || process.env[varName] || match;
  });
}

// Generate current profile environment file
function generateCurrentProfileEnv(profileName, profile, staticEnv) {
  const lines = [
    '# Generated by profile-manager.js - DO NOT EDIT MANUALLY',
    `# Profile: ${profileName} - ${profile.name}`,
    `# Generated: ${new Date().toISOString()}`,
    '',
    `CURRENT_PROFILE=${profileName}`
  ];
  
  // Add profile-specific environment variables
  for (const [key, value] of Object.entries(profile.environment)) {
    const resolvedValue = replaceEnvVars(value, staticEnv);
    lines.push(`${key}=${resolvedValue}`);
  }
  
  // Add computed values
  if (profile.database.connectionString) {
    const mongoUri = replaceEnvVars(profile.database.connectionString, staticEnv);
    lines.push(`MONGODB_URI=${mongoUri}`);
  }
  
  if (profile.frontend.apiUrl) {
    const apiUrl = replaceEnvVars(profile.frontend.apiUrl, staticEnv);
    lines.push(`API_BASE_URL=${apiUrl}`);
  }
  
  // Add required base environment variables from .env
  const requiredBaseVars = ['MONGODB_DB_NAME', 'AWS_REGION', 'RECIPE_IMAGES_BUCKET'];
  for (const varName of requiredBaseVars) {
    if (staticEnv[varName]) {
      lines.push(`${varName}=${staticEnv[varName]}`);
    }
  }

  // Add AI API keys if available in staticEnv
  const aiKeyNames = ['OPENAI_API_KEY', 'GOOGLE_API_KEY', 'GROQ_API_KEY', 'ANTHROPIC_API_KEY', 'DEEPSEEK_API_KEY'];
  const addedAiKeys = [];
  
  for (const keyName of aiKeyNames) {
    if (staticEnv[keyName]) {
      lines.push(`${keyName}=${staticEnv[keyName]}`);
      addedAiKeys.push(keyName);
    }
  }
  
  if (addedAiKeys.length > 0) {
    lines.splice(-addedAiKeys.length, 0, ''); // Add empty line before AI keys
    lines.splice(-addedAiKeys.length, 0, '# AI Provider API Keys');
  }
  
  const content = lines.join('\n') + '\n';
  
  try {
    fs.writeFileSync(CURRENT_PROFILE_FILE, content);
    log(`‚úÖ Generated ${CURRENT_PROFILE_FILE}`, 'green');
  } catch (error) {
    log(`‚ùå Error writing current profile file: ${error.message}`, 'red');
    process.exit(1);
  }
}

// Set current profile
async function setProfile(profileName) {
  const profiles = loadProfiles();
  
  if (!profiles.profiles[profileName]) {
    log(`‚ùå Profile '${profileName}' not found`, 'red');
    log(`Available profiles: ${Object.keys(profiles.profiles).join(', ')}`, 'yellow');
    process.exit(1);
  }
  
  const profile = profiles.profiles[profileName];
  let staticEnv = loadStaticEnv();
  
  log(`üîÑ Setting profile to: ${profileName} (${profile.name})`, 'blue');
  
  // For profiles using Atlas, try to fetch secrets from AWS Secrets Manager
  if (profile.database.type === 'atlas') {
    const secretName = staticEnv.AWS_SECRET_NAME || 'moms-recipe-secrets-dev';
    const region = staticEnv.AWS_REGION || 'us-west-2';
    
    log(`üîê Fetching secrets from AWS Secrets Manager...`, 'yellow');
    const secrets = await fetchSecretsFromAWS(secretName, region);
    
    // Handle MongoDB Atlas URI
    const atlasUri = secrets.MONGODB_URI || secrets.MONGODB_ATLAS_URI;
    if (atlasUri) {
      // Set the environment variable for this session
      process.env.MONGODB_ATLAS_URI = atlasUri;
      staticEnv.MONGODB_ATLAS_URI = atlasUri;
      
      // Also write to a temp file that can be sourced
      const envFile = path.join(CONFIG_DIR, '.mongodb_atlas_uri');
      fs.writeFileSync(envFile, `MONGODB_ATLAS_URI=${atlasUri}\n`);
      
      log(`‚úÖ Successfully retrieved MongoDB Atlas URI from AWS Secrets Manager`, 'green');
    } else {
      log(`‚ö†Ô∏è  Could not fetch MongoDB Atlas URI from AWS Secrets Manager`, 'yellow');
    }
    
    // Handle AI API Keys
    const aiKeyNames = ['OPENAI_API_KEY', 'GOOGLE_API_KEY', 'GROQ_API_KEY', 'ANTHROPIC_API_KEY', 'DEEPSEEK_API_KEY'];
    const foundAiKeys = [];
    
    for (const keyName of aiKeyNames) {
      if (secrets[keyName]) {
        process.env[keyName] = secrets[keyName];
        staticEnv[keyName] = secrets[keyName];
        foundAiKeys.push(keyName);
      }
    }
    
    if (foundAiKeys.length > 0) {
      log(`‚úÖ Successfully retrieved ${foundAiKeys.length} AI API key(s): ${foundAiKeys.join(', ')}`, 'green');
    } else {
      log(`‚ö†Ô∏è  No AI API keys found in AWS Secrets Manager`, 'yellow');
      log(`   AI Recipe Assistant will not be available`, 'yellow');
    }

    // Handle Auth0 Credentials
    const auth0KeyNames = [
      'AUTH0_DOMAIN',
      'AUTH0_M2M_CLIENT_ID', 
      'AUTH0_M2M_CLIENT_SECRET',
      'AUTH0_MRB_CLIENT_ID',
      'AUTH0_MRB_CLIENT_SECRET',
      'AUTH0_API_AUDIENCE',
      'AUTH0_MANAGEMENT_AUDIENCE'
    ];
    const foundAuth0Keys = [];
    
    for (const keyName of auth0KeyNames) {
      if (secrets[keyName]) {
        process.env[keyName] = secrets[keyName];
        staticEnv[keyName] = secrets[keyName];
        foundAuth0Keys.push(keyName);
      }
    }
    
    if (foundAuth0Keys.length > 0) {
      log(`‚úÖ Successfully retrieved ${foundAuth0Keys.length} Auth0 credential(s): ${foundAuth0Keys.join(', ')}`, 'green');
    } else {
      log(`‚ö†Ô∏è  No Auth0 credentials found in AWS Secrets Manager`, 'yellow');
      log(`   Auth0 authentication will not be available`, 'yellow');
    }
    
    if (!atlasUri && foundAiKeys.length === 0) {
      log(`   Make sure AWS credentials are configured and you have access to secret: ${secretName}`, 'yellow');
      log(`   Falling back to environment variable or .env file`, 'yellow');
    }
    
    log(`üí° Environment variables set for Docker Compose`, 'cyan');
  }
  
  // Update current profile in config
  profiles.currentProfile = profileName;
  saveProfiles(profiles);
  
  // Generate current profile environment file
  generateCurrentProfileEnv(profileName, profile, staticEnv);
  
  log(`‚úÖ Profile set to ${profileName}`, 'green');
  log(`üìù Description: ${profile.description}`, 'cyan');
}

// Show current profile
function showProfile() {
  const profiles = loadProfiles();
  const currentProfileName = profiles.currentProfile;
  const currentProfile = profiles.profiles[currentProfileName];
  
  if (!currentProfile) {
    log(`‚ùå Current profile '${currentProfileName}' not found`, 'red');
    return;
  }
  
  log(`\nüìä Current Profile: ${currentProfileName}`, 'cyan');
  log(`üìù Name: ${currentProfile.name}`, 'blue');
  log(`üìã Description: ${currentProfile.description}`, 'blue');
  log(`\nüèóÔ∏è  Architecture:`, 'yellow');
  log(`   Database: ${currentProfile.database.type}`, 'white');
  log(`   Backend: ${currentProfile.backend.type}`, 'white');
  log(`   Frontend: ${currentProfile.frontend.type}`, 'white');
  
  if (currentProfile.docker.services.length > 0) {
    log(`\nüê≥ Docker Services:`, 'yellow');
    currentProfile.docker.services.forEach(service => {
      log(`   - ${service}`, 'white');
    });
  }
  
  log(`\nüîß Environment Variables:`, 'yellow');
  for (const [key, value] of Object.entries(currentProfile.environment)) {
    log(`   ${key}=${value}`, 'white');
  }
}

// List all profiles
function listProfiles() {
  const profiles = loadProfiles();
  const currentProfileName = profiles.currentProfile;
  
  log(`\nüìã Available Profiles:`, 'cyan');
  
  for (const [name, profile] of Object.entries(profiles.profiles)) {
    const current = name === currentProfileName ? ' (current)' : '';
    log(`\n${name}${current}`, current ? 'green' : 'blue');
    log(`  ${profile.description}`, 'white');
    log(`  Database: ${profile.database.type} | Backend: ${profile.backend.type} | Frontend: ${profile.frontend.type}`, 'white');
  }
}

// Start infrastructure for current profile
function startInfrastructure() {
  const profiles = loadProfiles();
  const currentProfileName = profiles.currentProfile;
  const currentProfile = profiles.profiles[currentProfileName];
  
  log(`üöÄ Starting infrastructure for profile: ${currentProfileName}`, 'blue');
  
  if (currentProfile.docker.services.length === 0) {
    log(`‚ÑπÔ∏è  Profile '${currentProfileName}' uses external services - no local infrastructure to start`, 'yellow');
    return;
  }
  
  try {
    const dockerProfile = currentProfile.docker.profile;
    if (dockerProfile) {
      log(`üê≥ Starting Docker services with profile: ${dockerProfile}`, 'blue');
      
      // Load environment variables for Docker
      const staticEnv = loadStaticEnv();
      const dockerEnv = { 
        ...process.env,
        ...staticEnv
      };
      
      // Load MongoDB Atlas URI from temp file if it exists
      const envFile = path.join(CONFIG_DIR, '.mongodb_atlas_uri');
      if (fs.existsSync(envFile)) {
        const envContent = fs.readFileSync(envFile, 'utf8');
        const match = envContent.match(/MONGODB_ATLAS_URI=(.+)/);
        if (match) {
          dockerEnv.MONGODB_ATLAS_URI = match[1].trim();
          log(`üîó Using MongoDB Atlas URI from AWS Secrets Manager`, 'cyan');
        }
      }
      
      // For atlas profiles, ensure MONGODB_ATLAS_URI is available
      if (currentProfile.database.type === 'atlas' && !dockerEnv.MONGODB_ATLAS_URI) {
        log(`‚ö†Ô∏è  No MongoDB Atlas URI available - check AWS Secrets Manager access`, 'yellow');
      }
      
      execSync(`docker-compose --profile ${dockerProfile} up -d`, { 
        stdio: 'inherit',
        cwd: ROOT_DIR,
        env: dockerEnv
      });
      log(`‚úÖ Infrastructure started successfully`, 'green');
    }
  } catch (error) {
    log(`‚ùå Error starting infrastructure: ${error.message}`, 'red');
    process.exit(1);
  }
}

// Stop infrastructure for current profile
function stopInfrastructure() {
  const profiles = loadProfiles();
  const currentProfileName = profiles.currentProfile;
  
  log(`üõë Stopping infrastructure for profile: ${currentProfileName}`, 'blue');
  
  try {
    // Load environment variables for Docker
    const staticEnv = loadStaticEnv();
    const dockerEnv = { 
      ...process.env,
      ...staticEnv
    };
    
    // Stop all profiles to ensure clean state
    execSync('docker-compose --profile local --profile atlas down', { 
      stdio: 'inherit',
      cwd: ROOT_DIR,
      env: dockerEnv
    });
    log(`‚úÖ Infrastructure stopped successfully`, 'green');
  } catch (error) {
    log(`‚ùå Error stopping infrastructure: ${error.message}`, 'red');
    process.exit(1);
  }
}

// Validate current profile
function validateProfile() {
  const profiles = loadProfiles();
  const currentProfileName = profiles.currentProfile;
  const currentProfile = profiles.profiles[currentProfileName];
  
  log(`üîç Validating profile: ${currentProfileName}`, 'blue');
  
  const staticEnv = loadStaticEnv();
  let valid = true;
  
  // Check required environment variables
  const requiredVars = ['MONGODB_DB_NAME', 'AWS_REGION', 'RECIPE_IMAGES_BUCKET'];
  
  for (const varName of requiredVars) {
    if (!staticEnv[varName] && !process.env[varName]) {
      log(`‚ùå Missing required environment variable: ${varName}`, 'red');
      valid = false;
    }
  }
  
  // Check profile-specific requirements
  if (currentProfile.database.type === 'atlas') {
    if (!staticEnv.MONGODB_ATLAS_URI && !process.env.MONGODB_ATLAS_URI) {
      log(`‚ùå Missing MONGODB_ATLAS_URI for atlas database`, 'red');
      log(`   üí° Try: npm run profile:set ${profiles.currentProfile} (will fetch from AWS Secrets Manager)`, 'yellow');
      log(`   üí° Or set MONGODB_ATLAS_URI environment variable manually`, 'yellow');
      valid = false;
    }
  }
  
  if (currentProfile.backend.type === 'lambda') {
    if (!staticEnv.LAMBDA_API_URL && !process.env.LAMBDA_API_URL) {
      log(`‚ùå Missing LAMBDA_API_URL for lambda backend`, 'red');
      valid = false;
    }
  }
  
  if (valid) {
    log(`‚úÖ Profile validation passed`, 'green');
  } else {
    log(`‚ùå Profile validation failed`, 'red');
    process.exit(1);
  }
}

// Show usage
function showUsage() {
  console.log(`
üîÑ Profile Manager for Mom's Recipe Box

Usage: node scripts/profile-manager.js <command> [options]

Commands:
  show                    Show current profile details
  list                    List all available profiles
  set <profile>          Set active profile (local|atlas|lambda|cloud)
  start                  Start infrastructure for current profile
  stop                   Stop all infrastructure
  validate               Validate current profile configuration
  dev                    Start development environment for current profile

Examples:
  node scripts/profile-manager.js show
  node scripts/profile-manager.js set local
  node scripts/profile-manager.js start
  node scripts/profile-manager.js dev

NPM Shortcuts:
  npm run profile:show
  npm run profile:set local
  npm run profile:local
  npm run start
  npm run dev
`);
}

// Main function
async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    showBanner();
    showUsage();
    return;
  }
  
  const command = args[0];
  
  switch (command) {
    case 'show':
      showProfile();
      break;
    case 'list':
      listProfiles();
      break;
    case 'set':
      if (args.length < 2) {
        log('‚ùå Profile name required', 'red');
        log('Usage: npm run profile:set <profile>', 'yellow');
        process.exit(1);
      }
      await setProfile(args[1]);
      break;
    case 'start':
      startInfrastructure();
      break;
    case 'stop':
      stopInfrastructure();
      break;
    case 'validate':
      validateProfile();
      break;
    case 'dev':
      // Start development environment (infrastructure + UI if needed)
      startInfrastructure();
      // TODO: Add UI startup logic based on profile
      break;
    case 'help':
    case '--help':
      showUsage();
      break;
    default:
      log(`‚ùå Unknown command: ${command}`, 'red');
      showUsage();
      process.exit(1);
  }
}

// Run main function
(async () => {
  try {
    await main();
  } catch (error) {
    log(`‚ùå Error: ${error.message}`, 'red');
    process.exit(1);
  }
})();

export { 
  loadProfiles, 
  setProfile, 
  showProfile, 
  listProfiles, 
  startInfrastructure, 
  stopInfrastructure,
  validateProfile 
};